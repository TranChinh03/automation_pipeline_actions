# .github/workflows/auto-promote.yaml
name: üöÄ Auto Promote (Dynamic Environment Mapping & Auto-Merge)

# Trigger only when a Pull Request is successfully merged (closed event)
on:
  pull_request:
    types: [closed]
    branches:
      - dev
      - sit
      - uat
      - staging
      - production
      - main
      - release/**

# Required permissions for the GitHub Actions bot
permissions:
  contents: write    
  pull-requests: write 

jobs:
  promote:
    # Only run if the PR was merged (not just closed)
    if: github.event.pull_request.merged == true
    runs-on: ubuntu-latest

    steps:
      - name: ‚¨áÔ∏è Checkout Repository (Full History)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: üõ†Ô∏è Install jq & GitHub CLI
        run: |
          sudo apt-get update
          sudo apt-get install -y jq gh

      # ----------------------------------------------------------------------
      # 1. Load Environment Configuration (Logic Names)
      # ----------------------------------------------------------------------
      - name: ‚öôÔ∏è Load Environment Configuration
        id: load-envs
        run: |
          echo "üîç Loading environment list from .github/environments.json"
          if [ ! -f ".github/environments.json" ]; then
            echo "‚ùå File .github/environments.json does not exist! Please create it."
            exit 1
          fi
          
          # Extract all logic names into a space-separated string
          environments=$(jq -r '.environments[].name' .github/environments.json | tr '\n' ' ')
          
          if [ -z "$environments" ]; then
            echo "‚ùå File .github/environments.json tr·ªëng ho·∫∑c kh√¥ng ch·ª©a environments h·ª£p l·ªá!"
            exit 1
          fi
          
          echo "Read environments (logic names): $environments"
          echo "environments=$environments" >> $GITHUB_OUTPUT

          # Save the full JSON config to a file for later lookup (required for mapping)
          jq -c . .github/environments.json > environments.json
          echo "config_file_path=environments.json" >> $GITHUB_OUTPUT

      # ----------------------------------------------------------------------
      # 2. Extract selected LOGIC NAMES from the PR Body
      # ----------------------------------------------------------------------
      - name: üìù Extract Target Environments from PR body
        id: extract
        env:
          PR_BODY: ${{ github.event.pull_request.body }}
          ENVIRONMENTS: ${{ steps.load-envs.outputs.environments }} 
        shell: bash
        run: |
          set -e
          body="$PR_BODY"
          
          CLEAN_ENVIRONMENTS=$(echo "$ENVIRONMENTS" | tr '\n' ' ' | tr -s ' ')
          IFS=' ' read -r -a env_array <<< "$CLEAN_ENVIRONMENTS"
          selected_logic_names=()

          for env in "${env_array[@]}"; do
            echo "üî∏ Checking for logic name: [$env]"
            # Secure Regex pattern: searches for a line containing "- [x] logic_name"
            if echo "$body" | grep -iq "^\s*-\s*\\[x\\]\s*${env}"; then
              selected_logic_names+=("$env")
              echo "   ‚û°Ô∏è Found!"
            fi
          done

          if [ ${#selected_logic_names[@]} -eq 0 ]; then
            echo "‚ö†Ô∏è No target environments selected."
            echo "selected_names=" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "‚úÖ Selected logic names: ${selected_logic_names[*]}"
          echo "selected_names=${selected_logic_names[*]}" >> "$GITHUB_OUTPUT"

      - name: üõë Stop if no target branches
        if: steps.extract.outputs.selected_names == ''
        run: echo "‚èπÔ∏è No target environments selected. Skipping."

      # ----------------------------------------------------------------------
      # 3. Configure Git and Get Commit SHA
      # ----------------------------------------------------------------------
      - name: ü§ñ Configure Git
        if: steps.extract.outputs.selected_names != ''
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: üÜî Get Merge Commit SHA
        id: commit
        run: |
          sha=$(git rev-parse HEAD)
          echo "üí° Merge commit SHA: $sha"
          echo "sha=$sha" >> $GITHUB_OUTPUT

      # ----------------------------------------------------------------------
      # 4. Promote Code (Mapping Logic Name to Physical Branch) & Auto-Merge
      # ----------------------------------------------------------------------
      - name: ‚û°Ô∏è Promote to Selected Environments
        if: steps.extract.outputs.selected_names != '' 
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          sha=${{ steps.commit.outputs.sha }}
          base_branch=${{ github.base_ref }}
          # Ensure LOGIC_NAMES is treated as a simple string
          LOGIC_NAMES="${{ steps.extract.outputs.selected_names }}"
          
          # Load the full configuration JSON safely
          CONFIG=$(cat environments.json)
          
          # We don't need to put CONFIG in double quotes when piping to jq
          # The error is likely due to the shell's execution environment.
          
          IFS=' ' read -r -a names_to_promote <<< "$LOGIC_NAMES"
          
          for logic_name in "${names_to_promote[@]}"; do
            
            # --- 1. Map Logic Name to Physical Branch ---
            # Pipe the config to jq safely
            target_branch=$(echo "$CONFIG" | jq -r --arg name "$logic_name" '.environments[] | select(.name == $name) | .branch')
            
            if [ -z "$target_branch" ]; then
                echo "‚ùå Error: Could not find physical branch for environment '$logic_name'."
                continue
            fi
            
            echo "üîπ Promoting '$logic_name' (Physical branch: $target_branch)..."
            
            promotion_branch="promote-$base_branch-to-$logic_name/$sha" 
            PR_TITLE="Promote $base_branch ‚Üí $logic_name ($sha)"
          
            # --- 2. Git Operations (Cherry-pick) ---
            git fetch origin "${target_branch}" 2>/dev/null || echo "‚ö†Ô∏è Warning: Could not fetch ${target_branch}."
            git checkout -b "${promotion_branch}" origin/"${target_branch}" || git checkout -b "${promotion_branch}"
          
            if git cherry-pick -m 1 "$sha"; then
                echo "‚úÖ Cherry-pick succeeded."
            else
                echo "‚ùå Cherry-pick failed. Attempting cleanup..."
                git cherry-pick --abort 2>/dev/null || true 
                echo "‚ö†Ô∏è Automatic promotion skipped due to conflict on ${target_branch}."
                continue
            fi
          
            git push origin "${promotion_branch}" -f
          
            # --- 3. Check Branch Protection Rules ---
            # Ensure the gh api command handles errors gracefully
            PROTECTION_STATUS=$(gh api \
              "repos/${{ github.repository }}/branches/${target_branch}/protection" \
              --jq '.required_status_checks.enforcement_level, .required_pull_request_reviews.required_approving_review_count' 2>/dev/null || echo "not_protected")
              
            NEEDS_CHECKS=false
            # Check if the output contains anything other than the default error or null
            if [[ "$PROTECTION_STATUS" != "not_protected" && "$PROTECTION_STATUS" != "null" ]]; then
                NEEDS_CHECKS=true
            fi
            
            # --- 4. Create PR ---
            echo "üì¶ Creating promotion PR..."
            PR_URL=$(gh pr create \
              --base "${target_branch}" \
              --head "${promotion_branch}" \
              --title "$PR_TITLE" \
              --body "### üöÄ Automatic Promotion. The merge commit \`$sha\` from branch \`$base_branch\` has been applied to branch \`$target_branch\` (Logic Name: $logic_name). Please Review and Merge. --- *Automatically generated by GitHub Actions.*")
          
            echo "‚úÖ PR created: $PR_URL"
          
          done